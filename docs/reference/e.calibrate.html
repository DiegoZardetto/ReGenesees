<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Calibration of Survey Weights — e.calibrate • ReGenesees</title>

<!-- favicons -->
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png" />
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png" />

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />


<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Calibration of Survey Weights — e.calibrate" />
<meta property="og:description" content="Adds to an analytic object the calibrated weights column." />
<meta property="og:image" content="/logo.png" />
<meta name="twitter:card" content="summary" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">ReGenesees</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">2.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/Calibration_Efficiency_MC.html">On the Efficiency Gain of Calibration Estimators</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/DiegoZardetto/ReGenesees">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Calibration of Survey Weights</h1>
    
    <div class="hidden name"><code>e.calibrate.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Adds to an <code>analytic</code> object the calibrated weights column.</p>
    </div>

    <pre class="usage"><span class='fu'>e.calibrate</span>(<span class='no'>design</span>, <span class='no'>df.population</span>,
            <span class='kw'>calmodel</span> <span class='kw'>=</span> <span class='kw'>if</span> (<span class='fu'><a href='https://rdrr.io/r/base/class.html'>inherits</a></span>(<span class='no'>df.population</span>, <span class='st'>"pop.totals"</span>))
                       <span class='fu'><a href='https://rdrr.io/r/base/attr.html'>attr</a></span>(<span class='no'>df.population</span>, <span class='st'>"calmodel"</span>),
            <span class='kw'>partition</span> <span class='kw'>=</span> <span class='kw'>if</span> (<span class='fu'><a href='https://rdrr.io/r/base/class.html'>inherits</a></span>(<span class='no'>df.population</span>, <span class='st'>"pop.totals"</span>))
                        <span class='fu'><a href='https://rdrr.io/r/base/attr.html'>attr</a></span>(<span class='no'>df.population</span>, <span class='st'>"partition"</span>) <span class='kw'>else</span> <span class='fl'>FALSE</span>,
            <span class='kw'>calfun</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='st'>"linear"</span>, <span class='st'>"raking"</span>, <span class='st'>"logit"</span>),
            <span class='kw'>bounds</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(-<span class='fl'>Inf</span>, <span class='fl'>Inf</span>), <span class='kw'>aggregate.stage</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
            <span class='kw'>sigma2</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>maxit</span> <span class='kw'>=</span> <span class='fl'>50</span>, <span class='kw'>epsilon</span> <span class='kw'>=</span> <span class='fl'>1e-07</span>, <span class='kw'>force</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>design</th>
      <td><p>Object of class <code>analytic</code> (or inheriting from it) containing survey data and sampling design metadata.</p></td>
    </tr>
    <tr>
      <th>df.population</th>
      <td><p>Data frame containing the known population totals for the auxiliary variables.</p></td>
    </tr>
    <tr>
      <th>calmodel</th>
      <td><p>Formula defining the linear structure of the calibration model.</p></td>
    </tr>
    <tr>
      <th>partition</th>
      <td><p>Formula specifying the variables that define the "calibration domains" for the model (see &#8216;Details&#8217;); <code>FALSE</code> (the default) implies no calibration domains.</p></td>
    </tr>
    <tr>
      <th>calfun</th>
      <td><p><code>character</code> specifying the distance function for the calibration process; the default is
                <code>'linear'</code>.</p></td>
    </tr>
    <tr>
      <th>bounds</th>
      <td><p>Allowed range for the ratios between calibrated and initial weights; the default is
                <code><a href='https://rdrr.io/r/base/c.html'>c(-Inf,Inf)</a></code>.</p></td>
    </tr>
    <tr>
      <th>aggregate.stage</th>
      <td><p>An integer: if specified, causes the calibrated weights to be constant within sampling
                         units at this stage.</p></td>
    </tr>
    <tr>
      <th>sigma2</th>
      <td><p>Formula specifying a possible heteroskedasticity effect in the calibration model;
                <code>NULL</code> (the default) implies homoskedasticity.</p></td>
    </tr>
    <tr>
      <th>maxit</th>
      <td><p>Maximum number of iterations for the Newton-Raphson algorithm; the default is <code>50</code>.</p></td>
    </tr>
    <tr>
      <th>epsilon</th>
      <td><p>Tolerance for the absolute relative differences between the population totals and the corresponding
                 estimates based on the calibrated weights; the default is <code>10^-7</code>.</p></td>
    </tr>
    <tr>
      <th>force</th>
      <td><p>If <code>TRUE</code>, whenever the calibration algorithm does not converge, forces the function to return
               a value (see &#8216;Details&#8217; and &#8216;Calibration process diagnostics&#8217;); the default is <code>TRUE</code>.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>This function creates an object of class <code>cal.analytic</code>. A <code>cal.analytic</code> object makes it possible to compute estimates and standard errors of calibration estimators [Deville, Sarndal 92] [Deville, Sarndal, Sautory 93].</p>
<p>The mandatory argument <code>calmodel</code> symbolically defines the calibration model you intend to use, that is - in the language of the Generalized Regression Estimator - the assisting linear regression model underlying the calibration problem. More specifically, the <code>calmodel</code> formula identifies the auxiliary variables and the constraints for the calibration problem, with a notation inspired by [Wilkinson, Rogers 73]. For example, <code>calmodel=~(X+Z):C+(A+B):D-1</code> defines the calibration problem in which constraints are imposed: (i) on the totals of auxiliary (quantitative) variables <code>X</code> and <code>Z</code> within the subpopulations identified by the (qualitative) classification variable <code>C</code> and, at the same time, (ii) on the absolute frequency of the (qualitative) variables <code>A</code> and <code>B</code> within the subpopulations identified by the (qualitative) classification variable <code>D</code>.<br />
The <code>design</code> variables referenced by <code>calmodel</code> must be <code>numeric</code> or <code>factor</code> and must not contain any missing value (<code>NA</code>).</p>
<p>Problems for which one or more qualitative variables can be <em>&#8220;factorized&#8221;</em> in the formula that specifies the calibration model, are particularly interesting. These variables split the population into non-overlapping subpopulations known as <em>&#8220;calibration domains&#8221;</em> for the model. An example is provided by the statement <code>calmodel=~(A+B+X+Z):D-1</code> in which the variable that identifies the calibration domains is <code>D</code>; similarly, the formula <code>calmodel=~(A+B+X+Z):D1:D2-1</code> identifies as calibration domains the subpopulations determined by crossing the modalities of <code>D1</code> and <code>D2</code>. The interest in models of this kind lies in the fact that the <em>global</em> calibration problem they describe can, actually, be broken down into <em>local</em> subproblems, one per calibration domain, which can be solved separately [Vanderhoeft 01]. Thus, for example, the global problem defined by <code>calmodel=~(A+B+X+Z):D-1</code> is equivalent to the sequence of problems defined by the <em>&#8220;reduced model&#8221;</em> <code>calmodel=~A+B+X+Z-1</code> in each of the domains identified by the modalities of <code>D</code>. The opportunity to separately solve the subproblems related to different calibration domains achieves a significant reduction in computation complexity: the gain increases with increasing survey data size and (most importantly) with increasing auxiliary variables number.</p>
<p>The optional argument <code>partition</code> makes it possible to choose, in cases in which the calibration problem can be factorized, whether to solve the problem globally or in a partitioned way (that is, separately for each calibration domain). The global solution (which is the default option) can be selected invoking the <code>e.calibrate</code> function with <code>partition=FALSE</code>. To request the partitioned solution - a strongly recommended option when dealing with a lot of auxiliary variables and big data sizes - it is necessary to specify via <code>partition</code> the variables defining the calibration domains for the model. If a formula is passed through the <code>partition</code> argument (for example: <code>partition=~D1:D2</code>), the program checks that <code>calmodel</code> actually describes a "reduced model" (for example: <code>calmodel=~A+B+X+Z-1</code>), that is it does <em>not</em> reference any of the partition variables; if this is not the case, the program stops and prints an error message. Notice that a formula like <code>partition=~D1+D2</code> will be automatically translated into the factor-crossing formula <code>partition=~D1:D2</code>.<br />
The <code>design</code> variables referenced by <code>partition</code> (if any) must be <code>factor</code> and must not contain any missing value (<code>NA</code>).</p>
<p>The mandatory argument <code>df.population</code> is used to specify the known totals of the auxiliary variables referenced by <code>calmodel</code> within the subpopulations (if any) identified by <code>partition</code>. These known totals must be stored in a data frame whose structure (i) depends on the values of <code>calmodel</code> and <code>partition</code> and (ii) must conform to a standard. In order to facilitate understanding of and compliance with this standard, the <span class="pkg">ReGenesees</span> package provides the user with four functions: <code><a href='pop.template.html'>pop.template</a></code>, <code><a href='population.check.html'>population.check</a></code>, <code><a href='describe.html'>pop.desc</a></code> and <code><a href='fill.template.html'>fill.template</a></code>. The <code>pop.template</code> function is able to guide the user in constructing the known totals data frame for a specific calibration problem, the <code><a href='describe.html'>pop.desc</a></code> function provides a natural language description of the template structure, the <code><a href='fill.template.html'>fill.template</a></code> function can be exploited to automatically fill the template when a sampling frame is available, while the <code>population.check</code> function allows to check whether a known totals data frame conforms to the standard required by <code>e.calibrate</code>. In any case, if the <code>df.population</code> data frame does not comply with the standard, the <code>e.calibrate</code> function stops and prints an error message: the meaning of the message should help the user diagnose the cause of the problem.</p>
<p>The <code>calfun</code> argument identifies the distance function to be used in the calibration process. Three built-in functions are provided: <code>"linear"</code>, <code>"raking"</code>, and <code>"logit"</code> (see [Deville, Sarndal, Sautory 93]). The default is <code>"linear"</code>, which corresponds to the euclidean metric and yields the Generalized Regression Estimator (provided that no range restrictions are imposed on the g-weights). The <code>"raking"</code> distance corresponds to the <em>&#8220;multiplicative method&#8221;</em> of [Deville, Sarndal, Sautory 93].</p>
<p>The <code>bounds</code> argument allows to add <em>&#8220;range constraints&#8221;</em> to the calibration problem. To be precise, the interval defined by <code>bounds</code> will contain the values of the ratios between final (calibrated) and initial (direct) weights. The default value is <code><a href='https://rdrr.io/r/base/c.html'>c(-Inf,Inf)</a></code>, i.e. no range constraints are imposed. These constraints are optional unless the <code>"logit"</code> function is selected: in the latter case the range defined by <code>bounds</code> has to be finite (see, again, [Deville, Sarndal, Sautory 93]).</p>
<p>The value passed by the <code>aggregate.stage</code> argument must be an integer between <code>1</code> and the number of sampling stages of <code>design</code>. If specified, causes the calibrated weights to be constant within sampling units selected at the <code>aggregate.stage</code> stage (actually this is only allowed if the initial weights had already this property, as it is sometimes the case in multistage cluster sampling). If not specified, the calibrated weights may differ even for sampling units with identical initial weights. The same holds if some final units belonging to the same cluster selected at the stage <code>aggregate.stage</code> fall in distinct calibration domains (i.e. if the domains defined by <code>partition</code> "cut across" the <code>aggregate.stage</code>-stage clusters).</p>
<p>The argument <code>sigma2</code> can be used to take into account a possible heteroskedasticity effect in the (assisting linear regression model underlying the) calibration problem. In such cases, <code>sigma2</code> must identify some variable to which the variances of the error terms are believed to be proportional. Notice that <code>sigma2</code> can also be interpreted from a "purely calibration-based" point of view: it corresponds to the \(1/q_k\) unit-weights appearing inside the distance measures of [Deville, Sarndal 92] [Deville, Sarndal, Sautory 93]. The final effect is, on average, that <em>calibrated weights associated to higher values of</em> <code>sigma2</code> <em>tend to stay closer to their corresponding initial weights</em>.<br />
Note that it is technically possible to exploit this behaviour in order to <em>prevent some subset of the initial weights from being altered by calibration</em>. The trick is simple: just build a convenience <code>sigma2</code> variable whose values are set to some very high value (e.g. <code>1E12</code>) for those units whose initial weight must be preserved, and to <code>1</code> otherwise (see &#8216;Examples&#8217;). Nevertheless, this trick should be used sparingly and very carefully, as otherwise it may: (i) cause the calibration algorithm to not converge, (ii) result in introducing bias in calibration estimates. In particular, with respect to bias, one should not select the units whose weight must be preserved on the basis of the current sample.<br />
The <code>sigma2</code> formula can reference just a single <code>design</code> variable: such variable must be <code>numeric</code>, strictly positive and must not contain <code>NA</code>s. If <code>aggregate.stage</code> is specified, <code>sigma2</code> must obviously be constant inside <code>aggregate.stage</code>-stage clusters (otherwise the function stops and prints an error message).</p>
<p>The <code>maxit</code> argument sets the maximum number of iteration for the Newton-Raphson algorithm that is used to solve the calibration problem (the only exception being <em>unbounded  linear</em> calibration, i.e. <code>calfun='linear'</code> and <code>bounds=c(-Inf, Inf)</code>, which is actually handled by directly solving a linear problem). The default value of <code>maxit</code> is <code>50</code>.</p>
<p>The <code>epsilon</code> argument determines the convergence criterion for the optimization algorithm: it fixes the maximum allowed absolute value for the relative differences between the population totals and the corresponding estimates based on the calibrated weights. The default value is <code>10^-7</code>.</p>
<p>The calibrated weights computed by <code>e.calibrate</code> must ensure that the calibration estimators of the auxiliary variables <em>exactly</em> match the corresponding known population totals. It is, however, possible (more likely when range constraints are imposed) that, for a specific calibration problem and for given values of <code>epsilon</code> and <code>maxit</code>, the solving algorithm does not converge. In this case, if <code>force = FALSE</code>, <code>e.calibrate</code> stops and prints an error message. If - on the contrary - <code>force = TRUE</code>, the function is forced to return the best approximation achieved for the calibrated weights, nevertheless signaling the calibration failure by a warning (see also Section 'Calibration process diagnostics').</p>
    <h2 class="hasAnchor" id="calibration-process-diagnostics"><a class="anchor" href="#calibration-process-diagnostics"></a>Calibration Process Diagnostics</h2>

    <p>When, dealing with a factorizable calibration problem, the user selects the partitioned solution, the global calibration problem gets split into as many <em>sub-problems</em> as the number of subpopulations defined by <code>partition</code>. In turn, each one of these calibration sub-problems can end without convergence on any one of the involved auxiliary variables. A calibration process with such a complex structure needs some ad hoc tool for error diagnostics. For this purpose, every call to <code>e.calibrate</code> creates, by side effect, a dedicated data structure named <code>ecal.status</code> into the <code>.GlobalEnv</code>.</p>
<p><code>ecal.status</code> is a list with up to three components: the first, <code>"call"</code>, identifies the call to <code>e.calibrate</code> that generated the list, the second, <code>return.code</code>, is a matrix each element of which identifies the return code of a specific calibration sub-problem. The meaning of the return codes is as follows:</p><pre>
CODE        MEANING
  -1........not yet tackled sub-problem;
   0........solved sub-problem (convergence achieved);
   1........unsolved sub-problem (no convergence): output forced.
</pre>

<p>Recall that the latter return code (<code>1</code>) may only occur if <code>force = TRUE</code>.<br />
If any <code>return.code</code> equal to <code>1</code> exists, the <code>ecal.status</code> list gains a third component named <code>"fail.diagnostics"</code> which is itself a list; its components correspond to sub-problems for which convergence was not achieved, and store useful information about the auxiliary variables for which calibration constraints are violated. Therefore, users can exploit <code>ecal.status</code> to identify sub-problems and variables from which errors stemmed, hence taking a step forward to eliminate them.</p>
<p>Notice, lastly, that the <code>ecal.status</code> list will also be persistently bound to the <code>e.calibrate</code> return object, stored inside a dedicated attribute. For the inspection of such diagnostics information the <code><a href='check.cal.html'>check.cal</a></code> function is available.</p>
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>An object of class <code>cal.analytic</code>. The data frame it contains includes (in addition to the data already stored in <code>design</code>) the calibrated weights column. The name of this column is obtained by pasting the name of the initial weights column with the string <code>".cal"</code>.</p>
    <h2 class="hasAnchor" id="note"><a class="anchor" href="#note"></a>Note</h2>

    <p>The <code>cal.analytic</code> class is a specialization of the <code><a href='e.svydesign.html'>analytic</a></code> class; this means that an object created by <code>e.calibrate</code> inherits from the <code><a href='e.svydesign.html'>analytic</a></code> class and you can use on it all methods defined on the latter class, e.g. <code>print</code>, <code>summary</code>, <code><a href='weights.html'>weights</a></code>. Moreover, a calibrated design can be passed again to <code>e.calibrate</code>, thus undergoing further calibration steps.</p>
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Deville, J.C., Sarndal, C.E. (1992) <em>&#8220;Calibration Estimators in Survey Sampling&#8221;</em>, Journal of the American Statistical Association, Vol. 87, No. 418, pp. 376-382.</p>
<p>Deville, J.C., Sarndal, C.E., Sautory, O. (1993) <em>&#8220;Generalized Raking Procedures in Survey Sampling&#8221;</em>, Journal of the American Statistical Association, Vol. 88, No. 423, pp. 1013-1020.</p>
<p>Zardetto, D. (2015) <em>&#8220;ReGenesees: an Advanced R System for Calibration, Estimation and Sampling Error Assessment in Complex Sample Surveys&#8221;</em>. Journal of Official Statistics, 31(2), 177-203. doi: https://doi.org/10.1515/jos-2015-0013.</p>
<p>Wilkinson, G.N., Rogers, C.E. (1973) <em>&#8220;Symbolic Description of Factorial Models for Analysis of Variance&#8221;</em>, Journal of the Royal Statistical Society, series C (Applied Statistics), Vol. 22, pp. 181-191.</p>
<p>Vanderhoeft, C. (2001) <em>&#8220;Generalized Calibration at Statistic Belgium&#8221;</em>, Statistics Belgium Working Paper n. 3.</p>
<p>Sarndal, C.E., Lundstrom, S. (2005) Estimation in surveys with nonresponse. John Wiley &amp; Sons.</p>
<p>Scannapieco, M., Zardetto, D., Barcaroli, G. (2007) <em>&#8220;La Calibrazione dei Dati con R: una Sperimentazione sull'Indagine Forze di Lavoro ed un Confronto con GENESEES/SAS&#8221;</em>, Contributi Istat n. 4., <a href='https://www.istat.it/it/files/2018/07/2007_4.pdf'>https://www.istat.it/it/files/2018/07/2007_4.pdf</a>.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p><code><a href='e.svydesign.html'>e.svydesign</a></code> to bind survey data and sampling design metadata, <code><a href='svystatTM.html'>svystatTM</a></code>, <code><a href='svystatR.html'>svystatR</a></code>, <code><a href='svystatS.html'>svystatS</a></code>, <code><a href='svystatSR.html'>svystatSR</a></code>, <code><a href='svystatB.html'>svystatB</a></code>, <code><a href='svystatQ.html'>svystatQ</a></code> and <code><a href='svystatL.html'>svystatL</a></code> for calculating estimates and standard errors, <code><a href='pop.template.html'>pop.template</a></code> for constructing known totals data frames in compliance with the standard required by <code>e.calibrate</code>, <code><a href='population.check.html'>population.check</a></code> to check that the known totals data frame satisfies that standard, <code><a href='describe.html'>pop.desc</a></code> to provide a natural language description of the template structure, <code><a href='fill.template.html'>fill.template</a></code> to automatically fill the template when a sampling frame is available, <code><a href='bounds.hint.html'>bounds.hint</a></code> to obtain a hint for range restricted calibration, <code><a href='g.range.html'>g.range</a></code> to asses the variation of weights after calibration and <code><a href='check.cal.html'>check.cal</a></code> to check if calibration constraints have been fulfilled.</p></div>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'>######################################################################</span>
<span class='co'># Calibration of a design object according to different calibration  #</span>
<span class='co'># models (the known totals data frames pop01, \ldots, pop05p and the    #</span>
<span class='co'># bounds vector are all contained in the data.examples file).        #</span>
<span class='co'># For the examples relating to calibration models that can be        #</span>
<span class='co'># factorized both a global and a partitioned solution are given.     #</span>
<span class='co'>######################################################################</span>

<span class='co'># Load household data:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/data.html'>data</a></span>(<span class='no'>data.examples</span>)

<span class='co'># Creation of the object to be calibrated:</span>
<span class='no'>des</span><span class='kw'>&lt;-</span><span class='fu'><a href='e.svydesign.html'>e.svydesign</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>example</span>,<span class='kw'>ids</span><span class='kw'>=</span>~<span class='no'>towcod</span>+<span class='no'>famcod</span>,<span class='kw'>strata</span><span class='kw'>=</span>~<span class='no'>SUPERSTRATUM</span>,
     <span class='kw'>weights</span><span class='kw'>=</span>~<span class='no'>weight</span>)


<span class='co'># 1) Calibration on the total number of units in the population</span>
<span class='co'>#   (totals in pop01):</span>
<span class='no'>descal01</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop01</span>,<span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='fl'>1</span>,
          <span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>,<span class='kw'>aggregate.stage</span><span class='kw'>=</span><span class='fl'>2</span>)

<span class='co'># Printing descal01 immediately recalls that it is a</span>
<span class='co'># "calibrated" object:</span>
<span class='no'>descal01</span></div><div class='output co'>#&gt; Calibrated, Stratified 2 - Stage Cluster Sampling Design (with replacement)
#&gt; - [55] strata
#&gt; - [1307, 2372] clusters
#&gt; 
#&gt; Call:
#&gt; e.calibrate(design = des, df.population = pop01, calmodel = ~1, 
#&gt;     calfun = "logit", bounds = bounds, aggregate.stage = 2)</div><div class='input'>
<span class='co'># Use the summary() function if you need some additional details, e.g.:</span>
<span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span>(<span class='no'>descal01</span>)</div><div class='output co'>#&gt; Calibrated, Stratified 2 - Stage Cluster Sampling Design (with replacement)
#&gt; - [55] strata
#&gt; - [1307, 2372] clusters
#&gt; 
#&gt; Call:
#&gt; e.calibrate(design = des, df.population = pop01, calmodel = ~1, 
#&gt;     calfun = "logit", bounds = bounds, aggregate.stage = 2)
#&gt; 
#&gt; Weights:
#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#&gt;   95.09  217.86  318.55  306.10  360.75  927.21 
#&gt; 
#&gt; Sample stratum sizes: 
#&gt;       1  2  3  4  5  6  7  8  9 10 11 12 13 14  15 16 17 18 19 20 21 22 23 24
#&gt; Obs  15 26 36 36 27 53 66 34 51 31 15 18 81 12 152  6  2 33 57 14 17 60 55 71
#&gt; PSUs  2  2 32  2  2  2  3  2 43 28 12 12  3  2 128  6  2  2 39 12 12  2  2  2
#&gt;      25 26 27 28 29 30 31 32 33 34  35 36 37 38 39 40 41 42  43 44 45 46 47 48
#&gt; Obs  51 69 24 20 17 48 50 54 27 34 487 19 25 49 93 39 68 24 165 66 48 60 34 28
#&gt; PSUs  2  3 21 17  2 35  2  2  2  2 402 16 23  2  3 31  3  2 131 47 41 43 26 24
#&gt;      49 50 51 52 53 54 55
#&gt; Obs  68 48 55 88 28 75 71
#&gt; PSUs  2  2  2  3  2 58  2
#&gt; 
#&gt; Data variables:
#&gt;  [1] "towcod"       "famcod"       "key"          "weight"       "stratum"     
#&gt;  [6] "SUPERSTRATUM" "sr"           "regcod"       "procod"       "x1"          
#&gt; [11] "x2"           "x3"           "y1"           "y2"           "y3"          
#&gt; [16] "age5c"        "age10c"       "sex"          "marstat"      "z"           
#&gt; [21] "income"       "weight.cal"  </div><div class='input'>
<span class='co'># Use the 'variables' slot to extract survey data, e.g.:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span>(<span class='no'>descal01</span>$<span class='no'>variables</span>)</div><div class='output co'>#&gt;   towcod famcod key weight stratum SUPERSTRATUM sr regcod procod x1 x2 x3 y1 y2
#&gt; 1    147   3103   1  485.8     803           26  0      7      8  0  0  0  0  0
#&gt; 2    147   3103   2  485.8     803           26  0      7      8  0  0  0  1  1
#&gt; 3    147   3109   3  485.8     803           26  0      7      8  0  0  0  1  1
#&gt; 4    147   3111   4  485.8     803           26  0      7      8  0  0  0  0  0
#&gt; 5    147   3120   5  485.8     803           26  0      7      8  0  0  1  1  1
#&gt; 6    147   3121   6  485.8     803           26  0      7      8  0  0  0  0  0
#&gt;   y3 age5c age10c sex   marstat         z income weight.cal
#&gt; 1  0     3      5   f unmarried 148.32432   1158   481.6383
#&gt; 2  0     2      4   f   married  88.57746   1268   481.6383
#&gt; 3  0     3      6   f   married 115.07377    108   483.7165
#&gt; 4  0     4      7   f   married  86.37647   1700   483.7165
#&gt; 5  0     2      4   f   married 110.52172    537   483.7165
#&gt; 6  0     3      5   f   married 134.40092   2143   483.7165</div><div class='input'>
<span class='co'># Use the weights() function to extract weights, e.g.:</span>
<span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span>(<span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>descal01</span>))</div><div class='output co'>#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#&gt;   95.09  217.86  318.55  306.10  360.75  927.21 </div><div class='input'>
<span class='co'># Checking the result (first add the new 'ones' variable </span>
<span class='co'># to estimate the number of final units in the population):</span>
<span class='no'>descal01</span><span class='kw'>&lt;-</span><span class='fu'><a href='des.addvars.html'>des.addvars</a></span>(<span class='no'>descal01</span>,<span class='kw'>ones</span><span class='kw'>=</span><span class='fl'>1</span>)
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal01</span>, ~<span class='no'>ones</span>)</div><div class='output co'>#&gt;       Total           SE
#&gt; ones 918300 1.201834e-10</div><div class='input'>

<span class='co'># 2) Calibration on the marginal distributions of sex and marstat</span>
<span class='co'>#    (totals in pop02):</span>
<span class='no'>descal02</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop02</span>,
          <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>sex</span>+<span class='no'>marstat</span>-<span class='fl'>1</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>,
          <span class='kw'>aggregate.stage</span><span class='kw'>=</span><span class='fl'>2</span>)

<span class='co'># Checking the result:</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal02</span>,~<span class='no'>sex</span>+<span class='no'>marstat</span>)</div><div class='output co'>#&gt;                   Total           SE
#&gt; sexf             468366 3.355174e-11
#&gt; sexm             449934 4.622560e-11
#&gt; marstatmarried   532376 1.624207e-11
#&gt; marstatunmarried 311996 1.254943e-10
#&gt; marstatwidowed    73928 1.917476e-11</div><div class='input'>

<span class='co'># 3) Calibration (global solution) on the joint distribution of sex</span>
<span class='co'>#    and marstat (totals in pop03):</span>
<span class='no'>descal03</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop03</span>,
          <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>marstat</span>:<span class='no'>sex</span>-<span class='fl'>1</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>)

<span class='co'># Checking the result:</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal03</span>,~<span class='no'>sex</span>,~<span class='no'>marstat</span>) <span class='co'># or: svystatTM(descal03,~marstat,~sex)</span></div><div class='output co'>#&gt;             marstat Total.sexf Total.sexm SE.Total.sexf SE.Total.sexm
#&gt; married     married     272172     260204  6.673482e-11  4.242815e-11
#&gt; unmarried unmarried     159280     152716  8.637640e-12  2.957805e-11
#&gt; widowed     widowed      36914      37014  1.398840e-12  7.555014e-13</div><div class='input'>
<span class='co'># which, obviously, is not respected by descal02 (notice the size of SE):</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal02</span>,~<span class='no'>sex</span>,~<span class='no'>marstat</span>)</div><div class='output co'>#&gt;             marstat Total.sexf Total.sexm SE.Total.sexf SE.Total.sexm
#&gt; married     married  272111.67  260264.33      4697.938      4697.938
#&gt; unmarried unmarried  159238.03  152757.97      4438.246      4438.246
#&gt; widowed     widowed   37016.31   36911.69      2290.644      2290.644</div><div class='input'>

<span class='co'># 3.1) Again a calibration on the joint distribution of sex and marstat</span>
<span class='co'>#      but, this time, with the partitioned solution (partition=~sex,</span>
<span class='co'>#      totals in pop03p):</span>
<span class='no'>descal03p</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop03p</span>,
           <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>marstat</span>-<span class='fl'>1</span>,<span class='kw'>partition</span><span class='kw'>=</span>~<span class='no'>sex</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,
           <span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>)

<span class='co'># Checking the result:</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal03p</span>,~<span class='no'>sex</span>,~<span class='no'>marstat</span>)</div><div class='output co'>#&gt;             marstat Total.sexf Total.sexm SE.Total.sexf SE.Total.sexm
#&gt; married     married     272172     260204  6.673482e-11  4.475639e-11
#&gt; unmarried unmarried     159280     152716  8.637640e-12  3.381298e-11
#&gt; widowed     widowed      36914      37014  1.398840e-12  7.587658e-13</div><div class='input'>

<span class='co'># 4) Calibration (global solution) on the totals for the quantitative</span>
<span class='co'>#    variables x1, x2 and x3 in the subpopulations defined by the</span>
<span class='co'>#    regcod variable (totals in pop04):</span>
<span class='no'>descal04</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop04</span>,
          <span class='kw'>calmodel</span><span class='kw'>=</span>~(<span class='no'>x1</span>+<span class='no'>x2</span>+<span class='no'>x3</span>):<span class='no'>regcod</span>-<span class='fl'>1</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,
          <span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>,<span class='kw'>aggregate.stage</span><span class='kw'>=</span><span class='fl'>2</span>)

<span class='co'># Checking the result:</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal04</span>,~<span class='no'>x1</span>+<span class='no'>x2</span>+<span class='no'>x3</span>,~<span class='no'>regcod</span>)</div><div class='output co'>#&gt;    regcod Total.x1 Total.x2 Total.x3  SE.Total.x1  SE.Total.x2  SE.Total.x3
#&gt; 6       6    18403     5870     6525 2.528340e-12 1.041907e-12 4.874376e-13
#&gt; 7       7    22484     7557     8092 1.477221e-12 7.347449e-13 1.744538e-12
#&gt; 10     10    13726     4884     5659 7.875984e-13 3.360599e-13 5.570303e-13</div><div class='input'>

<span class='co'># 4.1) Same problem with the partitioned solution (partition=~regcod,</span>
<span class='co'>#      totals in pop04p):</span>
<span class='no'>descal04p</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop04p</span>,
           <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>x1</span>+<span class='no'>x2</span>+<span class='no'>x3</span>-<span class='fl'>1</span>,<span class='kw'>partition</span><span class='kw'>=</span>~<span class='no'>regcod</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,
           <span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>,<span class='kw'>aggregate.stage</span><span class='kw'>=</span><span class='fl'>2</span>)

<span class='co'># Checking the result:</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal04p</span>,~<span class='no'>x1</span>+<span class='no'>x2</span>+<span class='no'>x3</span>,~<span class='no'>regcod</span>)</div><div class='output co'>#&gt;    regcod Total.x1 Total.x2 Total.x3  SE.Total.x1  SE.Total.x2  SE.Total.x3
#&gt; 6       6    18403     5870     6525 3.377659e-12 1.343405e-12 5.599769e-13
#&gt; 7       7    22484     7557     8092 1.477221e-12 8.935162e-13 1.751581e-12
#&gt; 10     10    13726     4884     5659 6.495574e-13 2.544583e-13 4.316836e-13</div><div class='input'>

<span class='co'># 5) Calibration (global solution) on the total for the quantitative</span>
<span class='co'>#    variable x1 and on the marginal distribution of the qualitative</span>
<span class='co'>#    variable age5c, in the subpopulations defined by crossing sex</span>
<span class='co'>#    and marstat (totals in pop05):</span>
<span class='no'>descal05</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop05</span>,
          <span class='kw'>calmodel</span><span class='kw'>=</span>~(<span class='no'>age5c</span>+<span class='no'>x1</span>):<span class='no'>sex</span>:<span class='no'>marstat</span>-<span class='fl'>1</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,
          <span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>)

<span class='co'># Checking the result:</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal05</span>,~<span class='no'>age5c</span>+<span class='no'>x1</span>,~<span class='no'>sex</span>:<span class='no'>marstat</span>)</div><div class='output co'>#&gt;             sex   marstat Total.age5c1 Total.age5c2 Total.age5c3 Total.age5c4
#&gt; f.married     f   married        11023        92213       114859        47614
#&gt; m.married     m   married         7770        83894       122823        36003
#&gt; f.unmarried   f unmarried        56857        45467        46391         9573
#&gt; m.unmarried   m unmarried        49705        50453        39974        12122
#&gt; f.widowed     f   widowed         2099         8122        16437         8574
#&gt; m.widowed     m   widowed          561        12013        14556         8024
#&gt;             Total.age5c5 Total.x1 SE.Total.age5c1 SE.Total.age5c2
#&gt; f.married           6463    14750    1.235338e-12    1.272409e-11
#&gt; m.married           9714    18171    3.976661e-13    3.759196e-12
#&gt; f.unmarried          992     8446    1.132742e-12    2.141538e-12
#&gt; m.unmarried          462     8210    6.700997e-12    5.211010e-12
#&gt; f.widowed           1682     2737    9.508466e-14    2.842057e-13
#&gt; m.widowed           1860     2298    2.897581e-14    1.203842e-12
#&gt;             SE.Total.age5c3 SE.Total.age5c4 SE.Total.age5c5  SE.Total.x1
#&gt; f.married      2.203339e-11    6.260919e-12    1.776885e-13 4.639167e-12
#&gt; m.married      1.948546e-11    3.459667e-12    2.468354e-13 3.448681e-12
#&gt; f.unmarried    4.963355e-12    2.534411e-13    9.737936e-14 9.948751e-12
#&gt; m.unmarried    7.230665e-13    8.158830e-13    6.224669e-14 2.002933e-11
#&gt; f.widowed      6.995869e-13    7.100555e-13    1.905831e-13 3.481116e-13
#&gt; m.widowed      4.345409e-13    5.670255e-13    8.655409e-14 3.818179e-13</div><div class='input'>

<span class='co'># 5.1) Same problem with the partitioned solution (partition=~sex:marstat,</span>
<span class='co'>#      totals in pop05p):</span>
<span class='no'>descal05p</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop05p</span>,
           <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>age5c</span>+<span class='no'>x1</span>-<span class='fl'>1</span>,<span class='kw'>partition</span><span class='kw'>=</span>~<span class='no'>sex</span>:<span class='no'>marstat</span>,
           <span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>bounds</span>)

<span class='co'># Checking the result:</span>
<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal05p</span>,~<span class='no'>age5c</span>+<span class='no'>x1</span>,~<span class='no'>sex</span>:<span class='no'>marstat</span>)</div><div class='output co'>#&gt;             sex   marstat Total.age5c1 Total.age5c2 Total.age5c3 Total.age5c4
#&gt; f.married     f   married        11023        92213       114859        47614
#&gt; m.married     m   married         7770        83894       122823        36003
#&gt; f.unmarried   f unmarried        56857        45467        46391         9573
#&gt; m.unmarried   m unmarried        49705        50453        39974        12122
#&gt; f.widowed     f   widowed         2099         8122        16437         8574
#&gt; m.widowed     m   widowed          561        12013        14556         8024
#&gt;             Total.age5c5  Total.x1 SE.Total.age5c1 SE.Total.age5c2
#&gt; f.married           6463 14750.000    1.206965e-12    1.489651e-12
#&gt; m.married           9714 18171.000    4.175847e-13    8.763915e-12
#&gt; f.unmarried          992  8446.000    1.040497e-12    1.892746e-12
#&gt; m.unmarried          462  8210.001    9.082416e-12    4.539486e-12
#&gt; f.widowed           1682  2737.000    9.359915e-14    2.575470e-13
#&gt; m.widowed           1860  2298.000    9.631189e-14    1.450222e-12
#&gt;             SE.Total.age5c3 SE.Total.age5c4 SE.Total.age5c5  SE.Total.x1
#&gt; f.married      2.089462e-11    1.381439e-11    1.777031e-13 1.036177e-11
#&gt; m.married      2.107743e-11    3.450302e-12    3.029680e-13 3.038585e-12
#&gt; f.unmarried    7.742098e-12    2.922028e-12    1.614705e-13 3.140887e-12
#&gt; m.unmarried    8.345906e-13    7.762465e-13    5.818079e-14 1.241258e-12
#&gt; f.widowed      1.008660e-12    6.448378e-13    1.833791e-13 5.720334e-13
#&gt; m.widowed      4.310660e-13    4.817074e-13    7.750609e-14 4.162713e-13</div><div class='input'>
<span class='co'># Notice that 3.1 and 5.1) 5.2) do not impose the aggregate.stage=2</span>
<span class='co'># condition. This condition cannot, in fact, be fulfilled because</span>
<span class='co'># in both cases the domains defined by partition "cut across"</span>
<span class='co'># the des second stage clusters (households). To compare the results,</span>
<span class='co'># the same choice was also made for 3) and 5).</span>


<span class='co'># 5.2) Just a single example to inspect the ecal.status list generated</span>
<span class='co'>#      for diagnostics purposes.</span>
<span class='co'>#      Let's shrink the bounds in order to prevent perfect convergence</span>
<span class='co'>#      (recall that force=TRUE by default):</span>
<span class='no'>approx.cal</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>des</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop05p</span>,
            <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>age5c</span>+<span class='no'>x1</span>-<span class='fl'>1</span>,<span class='kw'>partition</span><span class='kw'>=</span>~<span class='no'>sex</span>:<span class='no'>marstat</span>,
            <span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"logit"</span>,<span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0.95</span>,<span class='fl'>1.05</span>))</div><div class='output co'>#&gt; <span class='warning'>Warning: Failed to converge: worst achieved epsilon= 0.0264941359907803 in 51 iterations (variable x1), see ecal.status.</span></div><div class='output co'>#&gt; <span class='warning'>Warning: Failed to converge: worst achieved epsilon= 0.0634422936449963 in 51 iterations (variable x1), see ecal.status.</span></div><div class='output co'>#&gt; <span class='warning'>Warning: Failed to converge: worst achieved epsilon= 0.0419225750326229 in 51 iterations (variable x1), see ecal.status.</span></div><div class='input'>
<span class='co'># ...now use check.cal function to assess the amount of calibration</span>
<span class='co'># constraints violation:</span>
<span class='fu'><a href='check.cal.html'>check.cal</a></span>(<span class='no'>approx.cal</span>)</div><div class='output co'>#&gt; Calibration Constraints missed (at tolerance level epsilon = 1e-07): 4 out of 36
#&gt; - Summary of mismatches: 
#&gt; 
#&gt; $return.code
#&gt;      f.married f.unmarried f.widowed m.married m.unmarried m.widowed
#&gt; code         1           0         1         0           0         1
#&gt; 
#&gt; $fail.diagnostics
#&gt; $fail.diagnostics$f.married
#&gt;   Variable Population.Total Achieved.Estimate Difference Relative.Difference
#&gt; 6       x1            14750          15140.82    390.815          0.02649414
#&gt; 
#&gt; $fail.diagnostics$f.widowed
#&gt;   Variable Population.Total Achieved.Estimate Difference Relative.Difference
#&gt; 6       x1             2737          2910.705    173.705          0.06344229
#&gt; 
#&gt; $fail.diagnostics$m.widowed
#&gt;   Variable Population.Total Achieved.Estimate Difference Relative.Difference
#&gt; 6       x1             2298          2394.380     96.380          0.04192258
#&gt; 1   age5c1              561           568.385      7.385          0.01314057
#&gt; 
#&gt; 
#&gt; </div><div class='input'>
<span class='co'># ...or (equivalently) inspect directly ecal.status:</span>
<span class='no'>ecal.status</span></div><div class='output co'>#&gt; $return.code
#&gt;      f.married f.unmarried f.widowed m.married m.unmarried m.widowed
#&gt; code         1           0         1         0           0         1
#&gt; 
#&gt; $fail.diagnostics
#&gt; $fail.diagnostics$f.married
#&gt;   Variable Population.Total Achieved.Estimate Difference Relative.Difference
#&gt; 6       x1            14750          15140.82    390.815          0.02649414
#&gt; 
#&gt; $fail.diagnostics$f.widowed
#&gt;   Variable Population.Total Achieved.Estimate Difference Relative.Difference
#&gt; 6       x1             2737          2910.705    173.705          0.06344229
#&gt; 
#&gt; $fail.diagnostics$m.widowed
#&gt;   Variable Population.Total Achieved.Estimate Difference Relative.Difference
#&gt; 6       x1             2298          2394.380     96.380          0.04192258
#&gt; 1   age5c1              561           568.385      7.385          0.01314057
#&gt; 
#&gt; </div><div class='input'>

<span class='co'>#################################################</span>
<span class='co'># Some examples illustrating how calibration    #</span>
<span class='co'># can be exploited to reduce nonresponse bias   #</span>
<span class='co'># (see, e.g. [Sarndal, Lundstrom 05]).          #</span>
<span class='co'>#################################################</span>

<span class='co'># Load sbs data:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/data.html'>data</a></span>(<span class='no'>sbs</span>)

  <span class='co'>#######################</span>
  <span class='co'># Full-response case. #</span>
  <span class='co'>#######################</span>

  <span class='co'># Create a full-response design object:</span>
  <span class='no'>sbsdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='e.svydesign.html'>e.svydesign</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>sbs</span>,<span class='kw'>ids</span><span class='kw'>=</span>~<span class='no'>id</span>,<span class='kw'>strata</span><span class='kw'>=</span>~<span class='no'>strata</span>,<span class='kw'>weights</span><span class='kw'>=</span>~<span class='no'>weight</span>,<span class='kw'>fpc</span><span class='kw'>=</span>~<span class='no'>fpc</span>)

  <span class='co'># Now estimate the average value added and its 95% confidence interval:</span>
  <span class='no'>mean.VA</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>va.imp2</span>,<span class='kw'>estimator</span><span class='kw'>=</span><span class='st'>"Mean"</span>,<span class='kw'>vartype</span><span class='kw'>=</span> <span class='st'>"cvpct"</span>,
           <span class='kw'>conf.int</span><span class='kw'>=</span><span class='fl'>TRUE</span>,<span class='kw'>conf.lev</span><span class='kw'>=</span><span class='fl'>0.95</span>)
  <span class='no'>mean.VA</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)     CV%
#&gt; va.imp2 3250.599  3136.161  3365.038 1.79623</div><div class='input'>
  <span class='co'># Compare the obtained estimate with the true population parameter:</span>
  <span class='no'>MEAN.VA</span><span class='kw'>&lt;-</span><span class='fu'><a href='https://rdrr.io/r/base/mean.html'>mean</a></span>(<span class='no'>sbs.frame</span>$<span class='no'>va.imp2</span>)
  <span class='no'>MEAN.VA</span></div><div class='output co'>#&gt; [1] 3136.899</div><div class='input'>
  <span class='co'># We get a small overestimation of about 4%...</span>
  <span class='fl'>100</span>*(<span class='fu'><a href='https://rdrr.io/r/stats/coef.html'>coef</a></span>(<span class='no'>mean.VA</span>)-<span class='no'>MEAN.VA</span>)/<span class='no'>MEAN.VA</span></div><div class='output co'>#&gt;  va.imp2 
#&gt; 3.624619 </div><div class='input'>
  <span class='co'># which, anyway, doesn't indicate a significant bias for the</span>
  <span class='co'># full-response sample, because the 95% confidence interval</span>
  <span class='co'># covers the true value.</span>


  <span class='co'>##################################################</span>
  <span class='co'># Nonresponse case: assume a response propensity #</span>
  <span class='co'># which increases with enterprise size.          #</span>
  <span class='co'>##################################################</span>

  <span class='co'># Set bigger response probabilities for bigger firms,</span>
  <span class='co'># e.g. exploiting available information about the</span>
  <span class='co'># number of employees (emp.cl):</span>
  <span class='fu'><a href='https://rdrr.io/r/base/levels.html'>levels</a></span>(<span class='no'>sbs</span>$<span class='no'>emp.cl</span>)</div><div class='output co'>#&gt; [1] "[6,9]"    "(9,19]"   "(19,49]"  "(49,99]"  "(99,Inf]"</div><div class='input'>  <span class='no'>p.resp</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>.4</span>,<span class='fl'>.6</span>,<span class='fl'>.8</span>,<span class='fl'>.95</span>,<span class='fl'>.99</span>)

  <span class='co'># Tie response probabilities to sample observations:</span>
  <span class='no'>pr</span><span class='kw'>&lt;-</span><span class='no'>p.resp</span>[<span class='fu'><a href='https://rdrr.io/r/base/class.html'>unclass</a></span>(<span class='no'>sbs</span>$<span class='no'>emp.cl</span>)]

  <span class='co'># Now, randomly select a subsample of responding units from sbs:</span>
  <span class='fu'><a href='https://rdrr.io/r/base/Random.html'>set.seed</a></span>(<span class='fl'>12345</span>)          <span class='co'># (fix the RNG seed for reproducibility)</span>
  <span class='no'>rand</span><span class='kw'>&lt;-</span><span class='fu'><a href='https://rdrr.io/r/stats/Uniform.html'>runif</a></span>(<span class='fl'>1</span>:<span class='fu'><a href='https://rdrr.io/r/base/nrow.html'>nrow</a></span>(<span class='no'>sbs</span>))
  <span class='no'>sbs.nr</span><span class='kw'>&lt;-</span><span class='no'>sbs</span>[<span class='no'>rand</span><span class='kw'>&lt;</span><span class='no'>pr</span>,]

  <span class='co'># This implies an overall response rate of about 73%:</span>
  <span class='fu'><a href='https://rdrr.io/r/base/nrow.html'>nrow</a></span>(<span class='no'>sbs.nr</span>)/<span class='fu'><a href='https://rdrr.io/r/base/nrow.html'>nrow</a></span>(<span class='no'>sbs</span>)</div><div class='output co'>#&gt; [1] 0.7261543</div><div class='input'>
  <span class='co'># Treat the non-response sample as it was complete: this should</span>
  <span class='co'># lead to biased estimates of value added, as the latter is</span>
  <span class='co'># positively correlated with firms size...</span>
  <span class='no'>sbsdes.nr</span><span class='kw'>&lt;-</span><span class='fu'><a href='e.svydesign.html'>e.svydesign</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>sbs.nr</span>,<span class='kw'>ids</span><span class='kw'>=</span>~<span class='no'>id</span>,<span class='kw'>strata</span><span class='kw'>=</span>~<span class='no'>strata</span>,<span class='kw'>weights</span><span class='kw'>=</span>~<span class='no'>weight</span>)</div><div class='output co'>#&gt; 
#&gt; # Empty levels found in factors: nace5, dom1, strata
#&gt; # Empty levels have been dropped!
#&gt; </div><div class='input'>
  <span class='co'>#...indeed:</span>
  <span class='no'>old.op</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>options</a></span>(<span class='st'>"RG.lonely.psu"</span><span class='kw'>=</span><span class='st'>"adjust"</span>)   <span class='co'># (prevent lonely-PSUs troubles)</span>
  <span class='no'>mean.VA.nr</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes.nr</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>va.imp2</span>,<span class='kw'>estimator</span><span class='kw'>=</span><span class='st'>"Mean"</span>,
              <span class='kw'>vartype</span><span class='kw'>=</span> <span class='st'>"cvpct"</span>,<span class='kw'>conf.int</span><span class='kw'>=</span><span class='fl'>TRUE</span>,<span class='kw'>conf.lev</span><span class='kw'>=</span><span class='fl'>0.95</span>)
  <span class='no'>mean.VA.nr</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)      CV%
#&gt; va.imp2 4177.553  3948.632  4406.474 2.795861</div><div class='input'>
  <span class='co'># and, comparing with the true population average, we see a</span>
  <span class='co'># significant overestimation effect, with the 95% confidence</span>
  <span class='co'># interval not even covering the parameter:</span>
  <span class='no'>MEAN.VA</span></div><div class='output co'>#&gt; [1] 3136.899</div><div class='input'>
  <span class='co'># Nonresponse bias can be effectively reduced by calibrating</span>
  <span class='co'># on variables explaining the response propensity: e.g., in</span>
  <span class='co'># the present example, on the population distribution of emp.cl:</span>
    <span class='co'># Prepare the known totals template...</span>
    <span class='no'>N.emp.cl</span><span class='kw'>&lt;-</span><span class='fu'><a href='pop.template.html'>pop.template</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>sbs.nr</span>,<span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>emp.cl</span>-<span class='fl'>1</span>)</div><div class='output co'>#&gt; 
#&gt; # Empty levels found in factors: nace5, dom1, strata
#&gt; # Empty levels have been dropped!
#&gt; </div><div class='input'>    <span class='no'>N.emp.cl</span></div><div class='output co'>#&gt;   emp.cl[6,9] emp.cl(9,19] emp.cl(19,49] emp.cl(49,99] emp.cl(99,Inf]
#&gt; 1          NA           NA            NA            NA             NA</div><div class='input'>
    <span class='co'># Fill it by using the sampling frame...</span>
    <span class='no'>N.emp.cl</span><span class='kw'>&lt;-</span><span class='fu'><a href='fill.template.html'>fill.template</a></span>(<span class='no'>sbs.frame</span>,<span class='no'>N.emp.cl</span>)</div><div class='output co'>#&gt; 
#&gt; # Coherence check between 'universe' and 'template': OK
#&gt; </div><div class='input'>    <span class='no'>N.emp.cl</span></div><div class='output co'>#&gt;   emp.cl[6,9] emp.cl(9,19] emp.cl(19,49] emp.cl(49,99] emp.cl(99,Inf]
#&gt; 1        5310         4778          3617          1669           1944</div><div class='input'>
    <span class='co'># Lastly calibrate:</span>
      <span class='co'># Get a hint on the calibration bounds:</span>
      <span class='no'>hint</span><span class='kw'>&lt;-</span><span class='fu'><a href='bounds.hint.html'>bounds.hint</a></span>(<span class='no'>sbsdes.nr</span>,<span class='no'>N.emp.cl</span>)</div><div class='output co'>#&gt; 
#&gt; A starting suggestion: try to calibrate with bounds=c(0.242, 3.275)
#&gt; 
#&gt; Remark: this is just a hint, not an exact result
#&gt; Feasible bounds for calibration problem must cover the interval [1, 2.516]
#&gt; </div><div class='input'>      <span class='no'>sbscal.nr</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes.nr</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>N.emp.cl</span>,
                 <span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>hint</span>)
      <span class='no'>sbscal.nr</span></div><div class='output co'>#&gt; Calibrated, Stratified Independent Unit Sampling Design (with replacement)
#&gt; - [606] strata
#&gt; - [5017] units
#&gt; 
#&gt; Call:
#&gt; e.calibrate(design = sbsdes.nr, df.population = N.emp.cl, bounds = hint)</div><div class='input'>
  <span class='co'># Now estimate the average value added on the calibrated design:</span>
  <span class='no'>mean.VA.cal.nr</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal.nr</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>va.imp2</span>,<span class='kw'>estimator</span><span class='kw'>=</span><span class='st'>"Mean"</span>,
              <span class='kw'>vartype</span><span class='kw'>=</span> <span class='st'>"cvpct"</span>,<span class='kw'>conf.int</span><span class='kw'>=</span><span class='fl'>TRUE</span>,<span class='kw'>conf.lev</span><span class='kw'>=</span><span class='fl'>0.95</span>)

  <span class='co'># options(old.op)   # (reset variance estimation options)</span>

  <span class='co'># As expected, we see a significant bias reduction:</span>
  <span class='no'>MEAN.VA</span></div><div class='output co'>#&gt; [1] 3136.899</div><div class='input'>  <span class='no'>mean.VA.nr</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)      CV%
#&gt; va.imp2 4177.553  3948.632  4406.474 2.795861</div><div class='input'>  <span class='no'>mean.VA.cal.nr</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)      CV%
#&gt; va.imp2 3370.917  3155.589  3586.246 3.259153</div><div class='input'>
  <span class='co'># Even if the 95% confidence interval still doesn't cover the</span>
  <span class='co'># true value, by calibration we passed from an initial overestimation</span>
  <span class='co'># of about 33% to a 7% one: </span>
  <span class='fl'>100</span>*(<span class='fu'><a href='https://rdrr.io/r/stats/coef.html'>coef</a></span>(<span class='no'>mean.VA.nr</span>)-<span class='no'>MEAN.VA</span>)/<span class='no'>MEAN.VA</span></div><div class='output co'>#&gt;  va.imp2 
#&gt; 33.17462 </div><div class='input'>  <span class='fl'>100</span>*(<span class='fu'><a href='https://rdrr.io/r/stats/coef.html'>coef</a></span>(<span class='no'>mean.VA.cal.nr</span>)-<span class='no'>MEAN.VA</span>)/<span class='no'>MEAN.VA</span></div><div class='output co'>#&gt;  va.imp2 
#&gt; 7.460192 </div><div class='input'>

  <span class='co'>#################################################</span>
  <span class='co'># A multi-step calibration example showing that #</span>
  <span class='co'># a calibrated object can be calibrated again   #</span>
  <span class='co'># (this can be sometimes useful in practice):   #</span>
  <span class='co'># Step 1: calibrate to reduce nonresponse bias; #</span>
  <span class='co'># Step 2: calibrate again to gain efficiency.   #</span>
  <span class='co'>#################################################</span>

  <span class='co'># Suppose you already performed a first calibration step,</span>
  <span class='co'># as shown in the example above, with the aim of softening</span>
  <span class='co'># nonresponse bias:</span>
  <span class='no'>sbscal.nr</span></div><div class='output co'>#&gt; Calibrated, Stratified Independent Unit Sampling Design (with replacement)
#&gt; - [606] strata
#&gt; - [5017] units
#&gt; 
#&gt; Call:
#&gt; e.calibrate(design = sbsdes.nr, df.population = N.emp.cl, bounds = hint)</div><div class='input'>
  <span class='co'># Now you may want to calibrate again in order to reduce</span>
  <span class='co'># estimators variance, by using further available auxiliary</span>
  <span class='co'># information, e.g. the total number of employees (emp.num)</span>
  <span class='co'># and enterprises (ent) inside the domains obtained</span>
  <span class='co'># by crossing nace.macro and region:</span>

    <span class='co'># Build the second step population totals template:</span>
    <span class='no'>pop2</span><span class='kw'>&lt;-</span><span class='fu'><a href='pop.template.html'>pop.template</a></span>(<span class='no'>sbscal.nr</span>,
          <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>emp.num</span>+<span class='no'>ent</span>-<span class='fl'>1</span>,
          <span class='kw'>partition</span><span class='kw'>=</span>~<span class='no'>nace.macro</span>:<span class='no'>region</span>)

    <span class='co'># Use the fill.template function to (i) automatically compute</span>
    <span class='co'># the totals from the universe (sbs.frame) and (ii) safely fill</span>
    <span class='co'># the template:</span>
    <span class='no'>pop2</span><span class='kw'>&lt;-</span><span class='fu'><a href='fill.template.html'>fill.template</a></span>(<span class='kw'>universe</span><span class='kw'>=</span><span class='no'>sbs.frame</span>,<span class='kw'>template</span><span class='kw'>=</span><span class='no'>pop2</span>)</div><div class='output co'>#&gt; 
#&gt; # Coherence check between 'universe' and 'template': OK
#&gt; </div><div class='input'>
    <span class='co'># Now perform the second calibration step:</span>
        <span class='co'># Get a hint on the calibration bounds:</span>
        <span class='no'>hint2</span><span class='kw'>&lt;-</span><span class='fu'><a href='bounds.hint.html'>bounds.hint</a></span>(<span class='no'>sbscal.nr</span>,<span class='no'>pop2</span>)</div><div class='output co'>#&gt; 
#&gt; A starting suggestion: try to calibrate with bounds=c(0.691, 1.239)
#&gt; 
#&gt; Remark: this is just a hint, not an exact result
#&gt; Feasible bounds for calibration problem must cover the interval [0.828, 1.102]
#&gt; </div><div class='input'>        <span class='no'>sbscal.nr2</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal.nr</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop2</span>,
                    <span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>hint2</span>)

  <span class='co'># Notice that printing sbscal.nr2 you immediately understand</span>
  <span class='co'># that it is a "twice-calibrated" object: </span>
  <span class='no'>sbscal.nr2</span></div><div class='output co'>#&gt; Calibrated, Stratified Independent Unit Sampling Design (with replacement)
#&gt; - [606] strata
#&gt; - [5017] units
#&gt; 
#&gt; Call:
#&gt; 2: e.calibrate(design = sbscal.nr, df.population = pop2, bounds = hint2)
#&gt; 1: e.calibrate(design = sbsdes.nr, df.population = N.emp.cl, bounds = hint)</div><div class='input'>
  <span class='co'># Notice also that, even if the second calibration step causes</span>
  <span class='co'># sbscal.nr2 to be no more exactly calibrated with respect to </span>
  <span class='co'># emp.cl (look at the cvpct values)...</span>
  <span class='no'>old.op</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>options</a></span>(<span class='st'>"RG.lonely.psu"</span><span class='kw'>=</span><span class='st'>"adjust"</span>)   <span class='co'># (prevent lonely-PSUs troubles)</span>
  <span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal.nr2</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>emp.cl</span>,<span class='kw'>vartype</span><span class='kw'>=</span><span class='st'>"cvpct"</span>)</div><div class='output co'>#&gt;                   Total       CV%
#&gt; emp.cl[6,9]    5292.797 0.8556058
#&gt; emp.cl(9,19]   4761.984 0.6970512
#&gt; emp.cl(19,49]  3626.837 0.6768815
#&gt; emp.cl(49,99]  1679.097 0.5751650
#&gt; emp.cl(99,Inf] 1957.285 0.8686677</div><div class='input'>
  <span class='co'># ...the nonresponse bias has not been resurrected (i.e. it gets stuck</span>
  <span class='co'># to its previous 7%):</span>
  <span class='no'>mean.VA.cal.nr2</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal.nr2</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>va.imp2</span>,<span class='kw'>estimator</span><span class='kw'>=</span><span class='st'>"Mean"</span>,
                   <span class='kw'>vartype</span><span class='kw'>=</span> <span class='st'>"cvpct"</span>,<span class='kw'>conf.int</span><span class='kw'>=</span><span class='fl'>TRUE</span>,<span class='kw'>conf.lev</span><span class='kw'>=</span><span class='fl'>0.95</span>)

  <span class='fu'><a href='https://rdrr.io/r/base/options.html'>options</a></span>(<span class='no'>old.op</span>)   <span class='co'># (reset variance estimation options)</span>

  <span class='no'>mean.VA.cal.nr2</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)      CV%
#&gt; va.imp2 3361.037  3152.528  3569.545 3.165209</div><div class='input'>  <span class='fl'>100</span>*(<span class='fu'><a href='https://rdrr.io/r/stats/coef.html'>coef</a></span>(<span class='no'>mean.VA.cal.nr2</span>)-<span class='no'>MEAN.VA</span>)/<span class='no'>MEAN.VA</span></div><div class='output co'>#&gt;  va.imp2 
#&gt; 7.145207 </div><div class='input'>

  <span class='co'>##############################################################</span>
  <span class='co'># Provided the auxiliary variables are chosen in a smart way #</span>
  <span class='co'># a single calibration step can simultaneously succeed in:   #</span>
  <span class='co'># (i)  softening nonresponse bias;                           #</span>
  <span class='co'># (ii) reducing estimators variance.                         #</span>
  <span class='co'>##############################################################</span>

  <span class='co'># Let's come back to the original design with nonresponse:</span>
  <span class='no'>sbsdes.nr</span></div><div class='output co'>#&gt; Stratified Independent Unit Sampling Design (with replacement)
#&gt; - [606] strata
#&gt; - [5017] units
#&gt; 
#&gt; Call:
#&gt; e.svydesign(data = sbs.nr, ids = ~id, strata = ~strata, weights = ~weight)</div><div class='input'>
  <span class='co'># Now, let's try to calibrate simultaneously on (see examples above):</span>
  <span class='co'># (i)  the population distribution of emp.cl;</span>
  <span class='co'># (ii) the total number of employees (emp.num) and enterprises (ent)</span>
  <span class='co'>#      inside the domains obtained by crossing nace.macro and region:</span>

    <span class='co'># Build the population totals template (notice that we are now forced</span>
    <span class='co'># to a global calibration, as we are assuming to ignore emp.cl counts</span>
    <span class='co'># inside domains obtained by crossing nace.macro and region):</span>
    <span class='no'>pop1</span><span class='kw'>&lt;-</span><span class='fu'><a href='pop.template.html'>pop.template</a></span>(<span class='no'>sbs.nr</span>,
          <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>emp.cl</span>+(<span class='no'>emp.num</span>+<span class='no'>ent</span>):<span class='no'>nace.macro</span>:<span class='no'>region</span>-<span class='fl'>1</span>)</div><div class='output co'>#&gt; 
#&gt; # Empty levels found in factors: nace5, dom1, strata
#&gt; # Empty levels have been dropped!
#&gt; </div><div class='input'>
    <span class='co'># Use the fill.template function to (i) automatically compute</span>
    <span class='co'># the totals from the universe (sbs.frame) and (ii) safely fill</span>
    <span class='co'># the template:</span>
    <span class='no'>pop1</span><span class='kw'>&lt;-</span><span class='fu'><a href='fill.template.html'>fill.template</a></span>(<span class='kw'>universe</span><span class='kw'>=</span><span class='no'>sbs.frame</span>,<span class='kw'>template</span><span class='kw'>=</span><span class='no'>pop1</span>)</div><div class='output co'>#&gt; 
#&gt; # Coherence check between 'universe' and 'template': OK
#&gt; </div><div class='input'>
    <span class='co'># Now perform the single calibration step:</span>
        <span class='co'># Get a hint on the calibration bounds:</span>
        <span class='no'>hint1</span><span class='kw'>&lt;-</span><span class='fu'><a href='bounds.hint.html'>bounds.hint</a></span>(<span class='no'>sbsdes.nr</span>,<span class='no'>pop1</span>)</div><div class='output co'>#&gt; 
#&gt; A starting suggestion: try to calibrate with bounds=c(0.242, 3.275)
#&gt; 
#&gt; Remark: this is just a hint, not an exact result
#&gt; Feasible bounds for calibration problem must cover the interval [1, 2.516]
#&gt; </div><div class='input'>        <span class='no'>sbscal.nr1</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes.nr</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop1</span>,
                    <span class='kw'>bounds</span><span class='kw'>=</span><span class='no'>hint1</span>)

    <span class='no'>sbscal.nr1</span></div><div class='output co'>#&gt; Calibrated, Stratified Independent Unit Sampling Design (with replacement)
#&gt; - [606] strata
#&gt; - [5017] units
#&gt; 
#&gt; Call:
#&gt; e.calibrate(design = sbsdes.nr, df.population = pop1, bounds = hint1)</div><div class='input'>
  <span class='co'># Now:</span>
  <span class='co'># (i) verify the nonresponse bias reduction effect:</span>
    <span class='no'>old.op</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>options</a></span>(<span class='st'>"RG.lonely.psu"</span><span class='kw'>=</span><span class='st'>"adjust"</span>)  <span class='co'>#(prevent lonely-PSUs troubles)</span>
    <span class='no'>mean.VA.cal.nr1</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal.nr1</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>va.imp2</span>,<span class='kw'>estimator</span><span class='kw'>=</span><span class='st'>"Mean"</span>,
                     <span class='kw'>vartype</span><span class='kw'>=</span> <span class='st'>"cvpct"</span>,<span class='kw'>conf.int</span><span class='kw'>=</span><span class='fl'>TRUE</span>,<span class='kw'>conf.lev</span><span class='kw'>=</span><span class='fl'>0.95</span>)
    <span class='fu'><a href='https://rdrr.io/r/base/options.html'>options</a></span>(<span class='no'>old.op</span>)

    <span class='no'>mean.VA.cal.nr1</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)      CV%
#&gt; va.imp2 3349.107  3140.887  3557.326 3.172087</div><div class='input'>    <span class='fl'>100</span>*(<span class='fu'><a href='https://rdrr.io/r/stats/coef.html'>coef</a></span>(<span class='no'>mean.VA.cal.nr1</span>)-<span class='no'>MEAN.VA</span>)/<span class='no'>MEAN.VA</span></div><div class='output co'>#&gt;  va.imp2 
#&gt; 6.764894 </div><div class='input'>
  <span class='co'># thus we are back to ~7%, as for the previous 2-step calibration example.</span>

  <span class='co'># (ii) compare cvpct with the previous 2-step calibration example:</span>
  <span class='no'>mean.VA.cal.nr1</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)      CV%
#&gt; va.imp2 3349.107  3140.887  3557.326 3.172087</div><div class='input'>  <span class='no'>mean.VA.cal.nr2</span></div><div class='output co'>#&gt;             Mean CI.l(95%) CI.u(95%)      CV%
#&gt; va.imp2 3361.037  3152.528  3569.545 3.165209</div><div class='input'>
  <span class='co'># hence, both bias reduction and efficiency are almost the same in 2-step and</span>
  <span class='co'># single step calibration (auxiliary information being equal): the choice</span>
  <span class='co'># will often depend on practical considerations (e.g. convergence, computation</span>
  <span class='co'># time).  </span>


<span class='co'>############################################################################</span>
<span class='co'># Example with heteroskedastic assisting linear model: shows how to obtain #</span>
<span class='co'># the ratio estimator of a total by calibration.                           #</span>
<span class='co'>############################################################################</span>

<span class='co'># Load sbs data:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/data.html'>data</a></span>(<span class='no'>sbs</span>)

<span class='co'># Create the design object to be calibrated:</span>
<span class='no'>sbsdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='e.svydesign.html'>e.svydesign</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>sbs</span>,<span class='kw'>ids</span><span class='kw'>=</span>~<span class='no'>id</span>,<span class='kw'>strata</span><span class='kw'>=</span>~<span class='no'>strata</span>,<span class='kw'>weights</span><span class='kw'>=</span>~<span class='no'>weight</span>,<span class='kw'>fpc</span><span class='kw'>=</span>~<span class='no'>fpc</span>)

<span class='co'># Suppose you have to calibrate on the total amount of employees:</span>
<span class='co'># Prepare the template:</span>
<span class='no'>pop</span><span class='kw'>&lt;-</span><span class='fu'><a href='pop.template.html'>pop.template</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>sbsdes</span>,<span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>emp.num</span>-<span class='fl'>1</span>)
<span class='no'>pop</span></div><div class='output co'>#&gt;   emp.num
#&gt; 1      NA</div><div class='input'>
<span class='co'># Fill it by using the sampling frame (sbs.frame)...</span>
<span class='no'>pop</span><span class='kw'>&lt;-</span><span class='fu'><a href='fill.template.html'>fill.template</a></span>(<span class='no'>sbs.frame</span>,<span class='no'>pop</span>)</div><div class='output co'>#&gt; 
#&gt; # Coherence check between 'universe' and 'template': OK
#&gt; </div><div class='input'><span class='no'>pop</span></div><div class='output co'>#&gt;   emp.num
#&gt; 1  984394</div><div class='input'>
<span class='co'># ... thus the total number of employees is 984394.</span>
<span class='co'># Now calibrate assuming that error terms variances are proportional</span>
<span class='co'># to emp.num:</span>
<span class='no'>sbscal</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop</span>,<span class='kw'>sigma2</span><span class='kw'>=</span>~<span class='no'>emp.num</span>)

<span class='co'># Now compute the calibration estimator of the total</span>
<span class='co'># of value added (i.e. variable va.imp2)...</span>
<span class='no'>VA.tot.cal</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>va.imp2</span>)
<span class='no'>VA.tot.cal</span></div><div class='output co'>#&gt;            Total      SE
#&gt; va.imp2 56250232 1002997</div><div class='input'>
<span class='co'>#... and observe that this is identical to the ratio estimator of the total...</span>
<span class='no'>TOT.emp.num</span> <span class='kw'>&lt;-</span> <span class='no'>pop</span>[<span class='fl'>1</span>, <span class='fl'>1</span>]
<span class='no'>VA.ratio</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatL.html'>svystatL</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes</span>, <span class='fu'><a href='https://rdrr.io/r/base/expression.html'>expression</a></span>(<span class='no'>TOT.emp.num</span> * (<span class='no'>va.imp2</span>/<span class='no'>emp.num</span>)))</div><div class='output co'>#&gt; <span class='error'>Error in get(x): object 'TOT.emp.num' not found</span></div><div class='input'><span class='no'>VA.ratio</span></div><div class='output co'>#&gt; <span class='error'>Error in eval(expr, envir, enclos): object 'VA.ratio' not found</span></div><div class='input'>
<span class='co'># ...as it must be.</span>

<span class='co'># Recall that, for the calibration problem above, one must expect, by virtue of</span>
<span class='co'># simple theoretical arguments, that the g-weights are constant and equal to the</span>
<span class='co'># ratio between the known total of emp.num (984394) and its HT estimate.</span>
<span class='co'># This property is exactly satisfied by our numerical results, see below:</span>
<span class='no'>pop</span>[<span class='fl'>1</span>, <span class='fl'>1</span>]/<span class='fu'><a href='https://rdrr.io/r/stats/coef.html'>coef</a></span>(<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>sbsdes</span>, ~<span class='no'>emp.num</span>))</div><div class='output co'>#&gt;   emp.num 
#&gt; 0.9992246 </div><div class='input'><span class='fu'><a href='g.range.html'>g.range</a></span>(<span class='no'>sbscal</span>)</div><div class='output co'>#&gt;     g.min     g.max 
#&gt; 0.9992246 0.9992246 </div><div class='input'>
<span class='co'># ...as it must be.</span>


<span class='co'>#########################################################################</span>
<span class='co'># A second example of calibration with heteroskedastic assisting linear #</span>
<span class='co'># model. Shows that calibrated weights associated to higher values of   #</span>
<span class='co'># sigma2 tend to stay closer to their corresponding initial weights.    #</span>
<span class='co'>#########################################################################</span>

<span class='co'># Perform a calibration process which exploits as auxiliary</span>
<span class='co'># information the total number of employees (emp.num)</span>
<span class='co'># and enterprises (ent) inside the domains obtained by:</span>
<span class='co'>#  i) crossing nace2 and region;</span>
<span class='co'># ii) crossing emp.cl, region and nace.macro;</span>

<span class='co'># Build the population totals template:</span>
<span class='no'>pop</span><span class='kw'>&lt;-</span><span class='fu'><a href='pop.template.html'>pop.template</a></span>(<span class='no'>sbsdes</span>,
     <span class='kw'>calmodel</span><span class='kw'>=</span>~(<span class='no'>emp.num</span>+<span class='no'>ent</span>):(<span class='no'>nace2</span>+<span class='no'>emp.cl</span>:<span class='no'>nace.macro</span>)-<span class='fl'>1</span>,
     <span class='kw'>partition</span><span class='kw'>=</span>~<span class='no'>region</span>)

<span class='co'># Use the fill.template function to (i) automatically compute</span>
<span class='co'># the totals from the universe (sbs.frame) and (ii) safely fill</span>
<span class='co'># the template:</span>
<span class='no'>pop</span><span class='kw'>&lt;-</span><span class='fu'><a href='fill.template.html'>fill.template</a></span>(<span class='kw'>universe</span><span class='kw'>=</span><span class='no'>sbs.frame</span>,<span class='kw'>template</span><span class='kw'>=</span><span class='no'>pop</span>)</div><div class='output co'>#&gt; 
#&gt; # Coherence check between 'universe' and 'template': OK
#&gt; </div><div class='input'>
<span class='co'># Now calibrate:</span>
  <span class='co'># 1) First, without any heteroskedasticy effect</span>
  <span class='no'>sbscal1</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='no'>sbsdes</span>,<span class='no'>pop</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"linear"</span>,<span class='kw'>bounds</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0.01</span>, <span class='fl'>3</span>),
           <span class='kw'>sigma2</span><span class='kw'>=</span><span class='kw'>NULL</span>)

  <span class='co'># 2) Then, with heteroskedastic effect proportional to emp.num:</span>
  <span class='no'>sbscal2</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='no'>sbsdes</span>,<span class='no'>pop</span>,<span class='kw'>calfun</span><span class='kw'>=</span><span class='st'>"linear"</span>,<span class='kw'>bounds</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0.01</span>, <span class='fl'>3</span>),
           <span class='kw'>sigma2</span><span class='kw'>=</span>~<span class='no'>emp.num</span>)

<span class='co'># Compute the g-weights for both the calibrated objects:</span>
<span class='no'>g1</span><span class='kw'>&lt;-</span><span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbscal1</span>)/<span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbsdes</span>)
<span class='no'>g2</span><span class='kw'>&lt;-</span><span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbscal2</span>)/<span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbsdes</span>)

<span class='co'># Now visually compare the absolute deviations from 1 of the g-weights</span>
<span class='co'># as a function of emp.num:</span>
<span class='fu'><a href='https://rdrr.io/r/base/plot.html'>plot</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/Log.html'>log10</a></span>(<span class='no'>sbs</span>$<span class='no'>emp.num</span>),<span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>abs</a></span>(<span class='no'>g1</span>-<span class='fl'>1</span>), <span class='kw'>col</span><span class='kw'>=</span><span class='st'>"blue"</span>, <span class='kw'>pch</span><span class='kw'>=</span><span class='fl'>19</span>, <span class='kw'>cex</span><span class='kw'>=</span><span class='fl'>0.5</span>)</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/points.html'>points</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/Log.html'>log10</a></span>(<span class='no'>sbs</span>$<span class='no'>emp.num</span>),<span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>abs</a></span>(<span class='no'>g2</span>-<span class='fl'>1</span>), <span class='kw'>col</span><span class='kw'>=</span><span class='st'>"red"</span>, <span class='kw'>pch</span><span class='kw'>=</span><span class='fl'>19</span>, <span class='kw'>cex</span><span class='kw'>=</span><span class='fl'>0.5</span>)</div><div class='img'><img src='e.calibrate-1.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'>#...as emp.num grows red points clearly tend to stay closer to</span>
<span class='co'># the horizontal axis than blue ones, as expected.</span>


<span class='co'>#########################################################################</span>
<span class='co'># A third example. Shows how to exploit the sigma2 argument to prevent  #</span>
<span class='co'># some initial weights from being altered by calibration.               #</span>
<span class='co'>#########################################################################</span>

<span class='co'># Let's refer again to object sbsdes:</span>
<span class='no'>sbsdes</span></div><div class='output co'>#&gt; Stratified Independent Unit Sampling Design
#&gt; - [664] strata
#&gt; - [6909] units
#&gt; 
#&gt; Call:
#&gt; e.svydesign(data = sbs, ids = ~id, strata = ~strata, weights = ~weight, 
#&gt;     fpc = ~fpc)</div><div class='input'>
<span class='co'># Let's assume that for some reason we want to prevent the *highest* initial</span>
<span class='co'># weights from being altered by calibration:</span>
<span class='no'>dmax</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>max</a></span>(<span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbsdes</span>))
<span class='no'>dmax</span></div><div class='output co'>#&gt; [1] 19.75</div><div class='input'>
<span class='co'># The relevent units are the following 4:</span>
<span class='no'>to.keep</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/which.html'>which</a></span>(<span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbsdes</span>) <span class='kw'>==</span> <span class='no'>dmax</span>)
<span class='no'>to.keep</span></div><div class='output co'>#&gt; 877 878 879 880 
#&gt; 877 878 879 880 </div><div class='input'>
<span class='co'># Now, let's prepare a convenience variable (to be later bound to the 'sigma2'</span>
<span class='co'># argument of e.calibrate) whose values are set to a very high value (say 1E12)</span>
<span class='co'># for those units whose initial weight must be preserved, and to 1 otherwise.</span>
<span class='co'># For definiteness, let's call such variable 'fixed':</span>
<span class='no'>sbsdes</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='des.addvars.html'>des.addvars</a></span>(<span class='no'>sbsdes</span>, <span class='kw'>fixed</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/ifelse.html'>ifelse</a></span>(<span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbsdes</span>) <span class='kw'>==</span> <span class='no'>dmax</span>, <span class='fl'>1E12</span>, <span class='fl'>1</span>))

<span class='co'># Now, let's perform a calibration process which exploits as auxiliary</span>
<span class='co'># information the total number of employees (emp.num)</span>
<span class='co'># and enterprises (ent) inside the domains obtained by:</span>
<span class='co'>#  i) crossing region and emp.cl;</span>
<span class='co'># ii) crossing region and nace.macro;</span>

<span class='co'># Build the population totals template:</span>
<span class='no'>pop</span><span class='kw'>&lt;-</span><span class='fu'><a href='pop.template.html'>pop.template</a></span>(<span class='no'>sbsdes</span>,
     <span class='kw'>calmodel</span> <span class='kw'>=</span> ~(<span class='no'>emp.num</span> + <span class='no'>ent</span>):(<span class='no'>emp.cl</span> + <span class='no'>nace.macro</span>) - <span class='fl'>1</span>,
     <span class='kw'>partition</span> <span class='kw'>=</span> ~<span class='no'>region</span>)

<span class='co'># Use the fill.template function to (i) automatically compute</span>
<span class='co'># the totals from the universe (sbs.frame) and (ii) safely fill</span>
<span class='co'># the template:</span>
<span class='no'>pop</span><span class='kw'>&lt;-</span><span class='fu'><a href='fill.template.html'>fill.template</a></span>(<span class='kw'>universe</span><span class='kw'>=</span><span class='no'>sbs.frame</span>,<span class='kw'>template</span><span class='kw'>=</span><span class='no'>pop</span>)</div><div class='output co'>#&gt; 
#&gt; # Coherence check between 'universe' and 'template': OK
#&gt; </div><div class='input'>
<span class='co'># Now calibrate:</span>
  <span class='co'># 1) First, *without* any heteroskedasticy effect:</span>
       <span class='no'>sbscal1</span> <span class='kw'>&lt;-</span> <span class='fu'>e.calibrate</span>(<span class='no'>sbsdes</span>, <span class='no'>pop</span>, <span class='kw'>calfun</span> <span class='kw'>=</span> <span class='st'>"linear"</span>, <span class='kw'>sigma2</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)
       <span class='fu'><a href='g.range.html'>g.range</a></span>(<span class='no'>sbscal1</span>)</div><div class='output co'>#&gt;     g.min     g.max 
#&gt; 0.6947777 1.4307814 </div><div class='input'>
       <span class='co'>## As expected, calibration weights of the 4 units to.keep *differ* from</span>
       <span class='co'>## the corresponding initial weights:</span>
       <span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbsdes</span>)[<span class='no'>to.keep</span>]</div><div class='output co'>#&gt;   877   878   879   880 
#&gt; 19.75 19.75 19.75 19.75 </div><div class='input'>       <span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbscal1</span>)[<span class='no'>to.keep</span>]</div><div class='output co'>#&gt; [1] 19.91005 19.52097 19.78035 19.91005</div><div class='input'>
  <span class='co'># 2) Then, *with* heteroskedasticy effect given by our convenience variable</span>
  <span class='co'>#    'fixed':</span>
       <span class='no'>sbscal2</span> <span class='kw'>&lt;-</span> <span class='fu'>e.calibrate</span>(<span class='no'>sbsdes</span>, <span class='no'>pop</span>, <span class='kw'>calfun</span> <span class='kw'>=</span> <span class='st'>"linear"</span>, <span class='kw'>sigma2</span> <span class='kw'>=</span> ~<span class='no'>fixed</span>)
       <span class='fu'><a href='g.range.html'>g.range</a></span>(<span class='no'>sbscal2</span>)</div><div class='output co'>#&gt;     g.min     g.max 
#&gt; 0.6947863 1.4307814 </div><div class='input'>
       <span class='co'>## Let's verify that calibration weights of the 4 units to.keep are now</span>
       <span class='co'>## *equal* to the corresponding initial weights:</span>
       <span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbsdes</span>)[<span class='no'>to.keep</span>]</div><div class='output co'>#&gt;   877   878   879   880 
#&gt; 19.75 19.75 19.75 19.75 </div><div class='input'>       <span class='fu'><a href='weights.html'>weights</a></span>(<span class='no'>sbscal2</span>)[<span class='no'>to.keep</span>]</div><div class='output co'>#&gt; [1] 19.75 19.75 19.75 19.75</div><div class='input'>
       <span class='co'>## ...as it must be.</span>

<span class='co'># NOTE: It should be clear that the additional request to hold some weights</span>
<span class='co'>#       fixed while calibrating will - all other things being equal - increase</span>
<span class='co'>#       the probability of non-convergence of the calibration algorithm.</span>


<span class='co'>##############################################################</span>
<span class='co'># Calibrating simultaneously on unit-level and cluster-level #</span>
<span class='co'># auxiliary information: an household survey example.        #</span>
<span class='co'>##############################################################</span>

<span class='co'># Load household data:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/data.html'>data</a></span>(<span class='no'>data.examples</span>)

<span class='co'># Define the survey design: </span>
<span class='no'>exdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='e.svydesign.html'>e.svydesign</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>example</span>,<span class='kw'>ids</span><span class='kw'>=</span>~<span class='no'>towcod</span>+<span class='no'>famcod</span>,<span class='kw'>strata</span><span class='kw'>=</span>~<span class='no'>stratum</span>,
       <span class='kw'>weights</span><span class='kw'>=</span>~<span class='no'>weight</span>)

<span class='co'># Collapse strata to eliminate lonely PSUs:</span>
<span class='no'>exdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='collapse.strata.html'>collapse.strata</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>exdes</span>,<span class='kw'>block.vars</span><span class='kw'>=</span>~<span class='no'>sr</span>:<span class='no'>procod</span>)</div><div class='output co'>#&gt; 
#&gt; # All lonely strata (45) successfully collapsed!
#&gt; </div><div class='output co'>#&gt; <span class='warning'>Warning: No similarity score specified: achieved strata aggregation depends on the ordering of sample data</span></div><div class='input'>
<span class='co'># Now add new convenience variables to the design object:</span>
  <span class='co'>## 'houdensity': to estimate households counts</span>
  <span class='co'>## 'ones':       to estimate individuals counts</span>
<span class='no'>exdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='des.addvars.html'>des.addvars</a></span>(<span class='no'>exdes</span>,
                   <span class='kw'>houdensity</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/stats/ave.html'>ave</a></span>(<span class='no'>famcod</span>,<span class='no'>famcod</span>,<span class='kw'>FUN</span> <span class='kw'>=</span> <span class='kw'>function</span>(<span class='no'>x</span>) <span class='fl'>1</span>/<span class='fu'><a href='https://rdrr.io/r/base/length.html'>length</a></span>(<span class='no'>x</span>)),
                   <span class='kw'>ones</span><span class='kw'>=</span><span class='fl'>1</span>)

<span class='co'># Let's see how it's possible to calibrate *simultaneously* on:</span>
  <span class='co'># 1. the number of *individuals* crossclassified by sex, 5 age classes,</span>
  <span class='co'>#    and province;</span>
  <span class='co'># 2. the number of *households* by region.</span>

<span class='co'># First, for the purpose of running the example, let's generate some</span>
<span class='co'># artificial population totals. We have only to get HT estimates for</span>
<span class='co'># the auxiliary variables and perturb them randomly:</span>
  <span class='co'># Get HT estimates of auxiliary variables:</span>
  <span class='no'>xx</span><span class='kw'>&lt;-</span><span class='fu'><a href='cal.estimates.html'>aux.estimates</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>exdes</span>,<span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>houdensity</span>+<span class='no'>sex</span>:<span class='no'>age5c</span>:<span class='no'>procod</span>-<span class='fl'>1</span>,
                    <span class='kw'>partition</span><span class='kw'>=</span>~<span class='no'>regcod</span>)

  <span class='co'># Add a random uniform perturbation to these numbers:</span>
  <span class='fu'><a href='https://rdrr.io/r/base/Random.html'>set.seed</a></span>(<span class='fl'>12345</span>)   <span class='co'># Fix the RNG seed for reproducibility</span>
  <span class='no'>xx</span>[,-<span class='fl'>1</span>]<span class='kw'>&lt;-</span><span class='fu'><a href='https://rdrr.io/r/base/Round.html'>round</a></span>(<span class='no'>xx</span>[,-<span class='fl'>1</span>]*<span class='fu'><a href='https://rdrr.io/r/stats/Uniform.html'>runif</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/prod.html'>prod</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/dim.html'>dim</a></span>(<span class='no'>xx</span>[,-<span class='fl'>1</span>])),<span class='fl'>0.8</span>,<span class='fl'>1.2</span>))

<span class='co'># Now we have at hand our artificial population totals, and</span>
<span class='co'># we can proceed with the calibration task:</span>
<span class='no'>excal</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>exdes</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>xx</span>,<span class='kw'>calfun</span><span class='kw'>=</span> <span class='st'>"linear"</span>,
                   <span class='kw'>bounds</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>,<span class='fl'>3</span>),<span class='kw'>aggregate.stage</span><span class='kw'>=</span><span class='fl'>2</span>)

<span class='co'># To perceive the effect of calibration, let's e.g. compare the HT and</span>
<span class='co'># calibrated estimates of the average number of individuals per household</span>
<span class='co'># at population level:</span>
<span class='fu'><a href='svystatR.html'>svystatR</a></span>(<span class='no'>exdes</span>,~<span class='no'>ones</span>,~<span class='no'>houdensity</span>,<span class='kw'>vartype</span><span class='kw'>=</span><span class='st'>"cvpct"</span>)</div><div class='output co'>#&gt;                    Ratio       CV%
#&gt; ones/houdensity 1.259284 0.8744035</div><div class='input'><span class='fu'><a href='svystatR.html'>svystatR</a></span>(<span class='no'>excal</span>,~<span class='no'>ones</span>,~<span class='no'>houdensity</span>,<span class='kw'>vartype</span><span class='kw'>=</span><span class='st'>"cvpct"</span>)</div><div class='output co'>#&gt;                    Ratio          CV%
#&gt; ones/houdensity 1.133042 2.265184e-14</div><div class='input'>

<span class='co'>########################################</span>
<span class='co'># Calibrating on different patterns of #</span>
<span class='co'># "incomplete" auxiliary information.  #</span>
<span class='co'>########################################</span>

<span class='co'># Usually calibration constraints involve "complete auxiliary information",</span>
<span class='co'># i.e. totals which are known either:</span>
<span class='co'>#     (i)  for the target population as a whole (e.g. total number of</span>
<span class='co'>#          employees working in italian active enterprises at a given date);</span>
<span class='co'># or:</span>
<span class='co'>#     (ii) for each subpopulation belonging to a complete partition of</span>
<span class='co'>#          the target population (e.g. number of male and female people</span>
<span class='co'>#          residing in Italy at a given date).</span>
<span class='co'># </span>
<span class='co'># Anyway, it may happen sometimes that the available auxiliary information</span>
<span class='co'># is actually "incomplete", i.e. one doesn't know all the totals for all the</span>
<span class='co'># subpopulations in a partition, but rather only for some of them. As an</span>
<span class='co'># example, suppose marital status has categories "married", "unmarried",</span>
<span class='co'># and "widowed" and that one only knows the number of "unmarried" people.</span>
<span class='co'>#</span>
<span class='co'># In what follows I show how you can use ReGenesees to handle a calibration</span>
<span class='co'># task on "incomplete" auxiliary information.</span>

  <span class='co'>#####################</span>
  <span class='co'># A simple example. #</span>
  <span class='co'>#####################</span>

  <span class='co'># Load household data:</span>
  <span class='fu'><a href='https://rdrr.io/r/utils/data.html'>data</a></span>(<span class='no'>data.examples</span>)

  <span class='co'># Define the survey design:</span>
  <span class='no'>des</span><span class='kw'>&lt;-</span><span class='fu'><a href='e.svydesign.html'>e.svydesign</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>example</span>,<span class='kw'>ids</span><span class='kw'>=</span>~<span class='no'>towcod</span>+<span class='no'>famcod</span>,<span class='kw'>strata</span><span class='kw'>=</span>~<span class='no'>SUPERSTRATUM</span>,
       <span class='kw'>weights</span><span class='kw'>=</span>~<span class='no'>weight</span>)

  <span class='co'># Suppose you only know the number of "unmarried" people (let's say 398240)</span>
  <span class='co'># but you ignore "married" and "widowed" totals, and you want to calibrate</span>
  <span class='co'># on this incomplete information.</span>

  <span class='co'># First, add to the survey design a new numeric variable with value 1</span>
  <span class='co'># for unmarried people and 0 otherwise:</span>
  <span class='no'>des</span><span class='kw'>&lt;-</span><span class='fu'><a href='des.addvars.html'>des.addvars</a></span>(<span class='no'>des</span>,<span class='kw'>unmarried</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/base/numeric.html'>as.numeric</a></span>(<span class='no'>marstat</span><span class='kw'>==</span><span class='st'>"unmarried"</span>))

  <span class='co'># Second, prepare a template to store the known "unmarried" people count:</span>
  <span class='no'>pop</span><span class='kw'>&lt;-</span><span class='fu'><a href='pop.template.html'>pop.template</a></span>(<span class='no'>des</span>,<span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>unmarried</span>-<span class='fl'>1</span>)

  <span class='co'># Third, fill the template with the known total:</span>
  <span class='no'>pop</span>[<span class='fl'>1</span>,<span class='fl'>1</span>]<span class='kw'>&lt;-</span><span class='fl'>398240</span>

  <span class='co'># Fourth, calibrate:</span>
  <span class='no'>descal</span><span class='kw'>&lt;-</span><span class='fu'>e.calibrate</span>(<span class='no'>des</span>,<span class='no'>pop</span>)

  <span class='co'># Now test that only "unmarried" estimated total has 0 percent CV:</span>
  <span class='fu'><a href='Zapsmall.html'>Zapsmall</a></span>(<span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='no'>descal</span>,~<span class='no'>marstat</span>,<span class='kw'>vartype</span><span class='kw'>=</span><span class='st'>"cvpct"</span>))</div><div class='output co'>#&gt;                     Total      CV%
#&gt; marstatmarried   536680.2 2.603128
#&gt; marstatunmarried 398240.0 0.000000
#&gt; marstatwidowed    74766.6 7.865228</div><div class='input'>
  <span class='co'># ...as it must be.</span>


  <span class='co'>###############################</span>
  <span class='co'># A more complicated example. #</span>
  <span class='co'>###############################</span>

  <span class='co'># Load sbs data:</span>
  <span class='fu'><a href='https://rdrr.io/r/utils/data.html'>data</a></span>(<span class='no'>sbs</span>)

  <span class='co'># Define the survey design:</span>
  <span class='no'>sbsdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='e.svydesign.html'>e.svydesign</a></span>(<span class='kw'>data</span><span class='kw'>=</span><span class='no'>sbs</span>,<span class='kw'>ids</span><span class='kw'>=</span>~<span class='no'>id</span>,<span class='kw'>strata</span><span class='kw'>=</span>~<span class='no'>strata</span>,<span class='kw'>weights</span><span class='kw'>=</span>~<span class='no'>weight</span>,<span class='kw'>fpc</span><span class='kw'>=</span>~<span class='no'>fpc</span>)

  <span class='co'># Suppose you want to calibrate on the following "incomplete" known totals:</span>
    <span class='co'># 1. enterprises counts by nace.macro</span>
    <span class='co'># 2. enterprises counts by dom3 ONLY inside nace.macro 'Industry'</span>
    <span class='co'># 3. total of y by emp.cl ONLY inside nace.macro 'Commerce'</span>

  <span class='co'># First, add to the survey design new variables identifying the domains</span>
  <span class='co'># where "incomplete" totals 2. and 3. are known:</span>
  <span class='co'>## 2. -&gt; nace.macro = 'Industry'</span>
  <span class='no'>sbsdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='des.addvars.html'>des.addvars</a></span>(<span class='no'>sbsdes</span>,<span class='kw'>Industry</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/base/numeric.html'>as.numeric</a></span>(<span class='no'>nace.macro</span><span class='kw'>==</span><span class='st'>"Industry"</span>))
  <span class='co'>## 3. -&gt; nace.macro = 'Commerce'</span>
  <span class='no'>sbsdes</span><span class='kw'>&lt;-</span><span class='fu'><a href='des.addvars.html'>des.addvars</a></span>(<span class='no'>sbsdes</span>,<span class='kw'>Commerce</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/base/numeric.html'>as.numeric</a></span>(<span class='no'>nace.macro</span><span class='kw'>==</span><span class='st'>"Commerce"</span>))

  <span class='co'># Do the same for the sampling frame:</span>
  <span class='co'>## 2. -&gt; nace.macro = 'Industry'</span>
  <span class='no'>sbs.frame</span>$<span class='no'>Industry</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/base/numeric.html'>as.numeric</a></span>(<span class='no'>sbs.frame</span>$<span class='no'>nace.macro</span><span class='kw'>==</span><span class='st'>"Industry"</span>)
  <span class='co'>## 3. -&gt; nace.macro = 'Commerce'</span>
  <span class='no'>sbs.frame</span>$<span class='no'>Commerce</span><span class='kw'>=</span><span class='fu'><a href='https://rdrr.io/r/base/numeric.html'>as.numeric</a></span>(<span class='no'>sbs.frame</span>$<span class='no'>nace.macro</span><span class='kw'>==</span><span class='st'>"Commerce"</span>)

  <span class='co'># Second, prepare a template to store the totals listed in 1., 2. and 3.;</span>
  <span class='co'># to this purpose one can e.g. compute HT estimates of the involved auxiliary</span>
  <span class='co'># variables:</span>
  <span class='no'>Xht</span><span class='kw'>&lt;-</span><span class='fu'><a href='cal.estimates.html'>aux.estimates</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes</span>,
                     <span class='kw'>calmodel</span><span class='kw'>=</span>~<span class='no'>nace.macro</span>+<span class='no'>Industry</span>:<span class='no'>dom3</span>+<span class='no'>Commerce</span>:<span class='no'>y</span>:<span class='no'>emp.cl</span>-<span class='fl'>1</span>)
  <span class='no'>Xht</span></div><div class='output co'>#&gt;   nace.macroAgriculture nace.macroIndustry nace.macroCommerce
#&gt; 1                   458               9295               3060
#&gt;   nace.macroServices Industry:dom3A Industry:dom3B Industry:dom3C
#&gt; 1               4505       996.7548       1836.714       2679.449
#&gt;   Industry:dom3D Commerce:y:emp.cl[6,9] Commerce:y:emp.cl(9,19]
#&gt; 1       3782.082               994200.2                952217.6
#&gt;   Commerce:y:emp.cl(19,49] Commerce:y:emp.cl(49,99] Commerce:y:emp.cl(99,Inf]
#&gt; 1                  1141649                 528571.7                   1092825</div><div class='input'>
  <span class='co'># Third, use the structure above to compute actual population totals</span>
  <span class='co'># from the sampling frame:</span>
  <span class='no'>pop</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='fill.template.html'>fill.template</a></span>(<span class='kw'>universe</span><span class='kw'>=</span><span class='no'>sbs.frame</span>,<span class='kw'>template</span><span class='kw'>=</span><span class='no'>Xht</span>)</div><div class='output co'>#&gt; 
#&gt; # Coherence check between 'universe' and 'template': OK
#&gt; </div><div class='input'>  <span class='no'>pop</span></div><div class='output co'>#&gt;   nace.macroAgriculture nace.macroIndustry nace.macroCommerce
#&gt; 1                   458               9295               3060
#&gt;   nace.macroServices Industry:dom3A Industry:dom3B Industry:dom3C
#&gt; 1               4505            929           1887           2736
#&gt;   Industry:dom3D Commerce:y:emp.cl[6,9] Commerce:y:emp.cl(9,19]
#&gt; 1           3743                 829235                920114.9
#&gt;   Commerce:y:emp.cl(19,49] Commerce:y:emp.cl(49,99] Commerce:y:emp.cl(99,Inf]
#&gt; 1                 874545.5                 617231.3                   1092825</div><div class='input'>
  <span class='co'># Fourth, calibrate:</span>
  <span class='no'>sbscal</span> <span class='kw'>&lt;-</span> <span class='fu'>e.calibrate</span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbsdes</span>,<span class='kw'>df.population</span><span class='kw'>=</span><span class='no'>pop</span>)</div><div class='output co'>#&gt; <span class='warning'>Warning: Calibration system is singular: switching to Moore-Penrose generalized inverse.</span></div><div class='input'>
  <span class='co'># Test1: nace.macro counts have 0 CVs:</span>
  <span class='no'>test1</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>nace.macro</span>,<span class='kw'>vartype</span><span class='kw'>=</span><span class='st'>"cvpct"</span>)
  <span class='no'>test1</span></div><div class='output co'>#&gt;                       Total          CV%
#&gt; nace.macroAgriculture   458 1.624180e-14
#&gt; nace.macroIndustry     9295 9.551931e-16
#&gt; nace.macroCommerce     3060 6.655761e-15
#&gt; nace.macroServices     4505 9.898773e-15</div><div class='input'>
  <span class='co'># Test2: only 'Industry' macrosector has 0 CVs for dom3 counts:</span>
  <span class='no'>test2</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>dom3</span>,<span class='kw'>by</span><span class='kw'>=</span>~<span class='no'>nace.macro</span>,<span class='kw'>vartype</span><span class='kw'>=</span><span class='st'>"cvpct"</span>)
  <span class='fu'><a href='Zapsmall.html'>Zapsmall</a></span>(<span class='no'>test2</span>)</div><div class='output co'>#&gt;              nace.macro Total.dom3A Total.dom3B Total.dom3C Total.dom3D
#&gt; Agriculture Agriculture     49.5444     81.1017    146.1222     181.232
#&gt; Industry       Industry    929.0000   1887.0000   2736.0000    3743.000
#&gt; Commerce       Commerce    340.0833    605.7240    867.0806    1247.112
#&gt; Services       Services    369.1198    864.4677   1464.7315    1806.681
#&gt;             CV%.Total.dom3A CV%.Total.dom3B CV%.Total.dom3C CV%.Total.dom3D
#&gt; Agriculture       13.033464        9.725389        7.043994        6.070370
#&gt; Industry           0.000000        0.000000        0.000000        0.000000
#&gt; Commerce          15.429469       10.704505        8.355274        6.033396
#&gt; Services           8.141061        5.204686        3.846774        3.104347</div><div class='input'>
  <span class='co'># Test3: only 'Commerce' macrosector has 0 CVs for y total by emp.cl:</span>
  <span class='no'>test3</span><span class='kw'>&lt;-</span><span class='fu'><a href='svystatTM.html'>svystatTM</a></span>(<span class='kw'>design</span><span class='kw'>=</span><span class='no'>sbscal</span>,<span class='kw'>y</span><span class='kw'>=</span>~<span class='no'>y</span>,<span class='kw'>by</span><span class='kw'>=</span>~<span class='no'>emp.cl</span>:<span class='no'>nace.macro</span>,<span class='kw'>vartype</span><span class='kw'>=</span><span class='st'>"cvpct"</span>)
  <span class='fu'><a href='Zapsmall.html'>Zapsmall</a></span>(<span class='no'>test3</span>)</div><div class='output co'>#&gt;                        emp.cl  nace.macro Total.y CV%.Total.y
#&gt; [6,9].Agriculture       [6,9] Agriculture   64163   12.414212
#&gt; (9,19].Agriculture     (9,19] Agriculture   99690   13.716875
#&gt; (19,49].Agriculture   (19,49] Agriculture   61686    6.812144
#&gt; (49,99].Agriculture   (49,99] Agriculture   45631    6.678561
#&gt; (99,Inf].Agriculture (99,Inf] Agriculture  205111    0.000000
#&gt; [6,9].Industry          [6,9]    Industry  674088    4.802774
#&gt; (9,19].Industry        (9,19]    Industry 1045442    4.387148
#&gt; (19,49].Industry      (19,49]    Industry 2171441    3.529600
#&gt; (49,99].Industry      (49,99]    Industry 2132322    2.714548
#&gt; (99,Inf].Industry    (99,Inf]    Industry 8849633    0.186070
#&gt; [6,9].Commerce          [6,9]    Commerce  829235    0.000000
#&gt; (9,19].Commerce        (9,19]    Commerce  920115    0.000000
#&gt; (19,49].Commerce      (19,49]    Commerce  874546    0.000000
#&gt; (49,99].Commerce      (49,99]    Commerce  617231    0.000000
#&gt; (99,Inf].Commerce    (99,Inf]    Commerce 1092825    0.000000
#&gt; [6,9].Services          [6,9]    Services  569468    6.089376
#&gt; (9,19].Services        (9,19]    Services  602931    5.043844
#&gt; (19,49].Services      (19,49]    Services  673754    4.124922
#&gt; (49,99].Services      (49,99]    Services  587742    5.047610
#&gt; (99,Inf].Services    (99,Inf]    Services 4652882    0.000000</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      <li><a href="#details">Details</a></li>
      <li><a href="#calibration-process-diagnostics">Calibration Process Diagnostics</a></li>
      <li><a href="#value">Value</a></li>
      <li><a href="#note">Note</a></li>
      <li><a href="#references">References</a></li>
      <li><a href="#see-also">See also</a></li>
      <li><a href="#examples">Examples</a></li>
    </ul>

    <h2>Author</h2>
    <p>Diego Zardetto</p>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Diego Zardetto.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


